using System;
using System.Collections.Generic;
using System.Text;
using System.Numerics;

namespace CompactEC.CryptoAlgebra
{
    /// <summary>
    /// Algebraic group operations provider.
    /// 
    /// Used by <see cref="CryptoGroup{E}"/> as the implementation of
    /// the respective group operations.
    /// </summary>
    /// <typeparam name="E">The data type used for raw group elements the algebraic operations operate on.</typeparam>
    /// <remarks>
    /// ICryptoGroupAlgebra should not used directly by productive code. Use <see cref="ICryptoGroup"/>
    /// instead.
    /// 
    /// ICryptoGroupAlgebra is intended to facilitate implementing the <see cref="ICryptoGroup"/>
    /// interface by allowing an implementer to focus on the actual group operations without
    /// having to deal with boilerplate constructs. The aim is mostly to avoid code duplication.
    /// In the same manner, <see cref="CryptoGroupAlgebra{E}"/> implements this interface and
    /// provides useful default implementations for certain operations. It is the class that
    /// an implementer should extend to implement this interface.
    /// </remarks>
    public interface ICryptoGroupAlgebra<E> where E : struct
    {
        /// <summary>
        /// The order of the group.
        /// 
        /// The order expresses the number of unique group elements (as generated by the group's generator).
        /// </summary>
        BigInteger Order { get; }

        /// <summary>
        /// The generator of the group.
        /// 
        /// The generator is a group element that allows to generate the entire group by scalar multiplication.
        /// </summary>
        E Generator { get; }

        /// <summary>
        /// The neutral element of the group with respect to the addition operation.
        /// </summary>
        E NeutralElement { get; }

        /// <summary>
        /// The maximum bit length of elements of the group.
        /// 
        /// This is the number of bits required to represent any element of the group.
        /// </summary>
        int ElementBitLength { get; }

        /// <summary>
        /// The bit length of the group's order.
        /// 
        /// This is the number of bits required to represent any scalar factor.
        /// </summary>
        int OrderBitLength { get; }

        /// <summary>
        /// Generates a group element.
        /// 
        /// The element is obtained by scalar multiplication of the generator with the
        /// provided index.
        /// </summary>
        /// <param name="index">A positive scalar factor less than the group's order
        ///     that uniquely identifies the element to generate.
        /// </param>
        /// <returns>The group element uniquely identified by the index.</returns>
        E GenerateElement(BigInteger index);

        /// <summary>
        /// Negates a group element.
        /// 
        /// The returned element added to the given element will result in the neutral element of the group.
        /// </summary>
        /// <param name="e">The group element to negate.</param>
        /// <returns>The negation of the given element in the group.</returns>
        E Negate(E e);

        /// <summary>
        /// Multiplies a group element with a scalar factor.
        /// 
        /// Scalar multiplication is understood as adding the group element to itself
        /// as many times as dictated by the scalar factor.
        /// </summary>
        /// <param name="e">A group element.</param>
        /// <param name="k">A scalar.</param>
        /// <returns>The given element multiplied with the given scalar.</returns>
        E MultiplyScalar(E e, BigInteger k);

        /// <summary>
        /// Adds two group elements according to the addition semantics
        /// defined for this group.
        /// 
        /// The operation is commutative, (i.e., symmetric in its arguments).
        /// </summary>
        /// <param name="left">Group element to add.</param>
        /// <param name="right">Group element to add.</param>
        /// <returns>The result of the group addition.</returns>
        E Add(E left, E right);

        /// <summary>
        /// Checks whether an input of group element type is a valid element of the group.
        /// </summary>
        /// <param name="element">The group element type object to check for validity.</param>
        /// <returns>True if the given input is a valid group element.</returns>
        bool IsValid(E element);

        /// <summary>
        /// Restores a group element from a byte representation.
        /// </summary>
        /// <param name="buffer">Byte array holding a representation of a group element.</param>
        /// <returns>The loaded group element.</returns>
        E FromBytes(byte[] buffer);

        /// <summary>
        /// Converts a group element into a byte representation.
        /// </summary>
        /// <param name="element">The group element to convert.</param>
        /// <returns>A byte array holding a representation of the group element.</returns>
        byte[] ToBytes(E element);
    }
}
